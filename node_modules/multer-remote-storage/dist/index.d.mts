import { Request } from 'express';
import { Readable } from 'stream';
import { PutObjectCommandInput, S3Client, CompleteMultipartUploadCommandOutput, DeleteObjectCommandInput, S3ClientConfig } from '@aws-sdk/client-s3';
export { S3Client } from '@aws-sdk/client-s3';
import { Options } from '@aws-sdk/lib-storage';
export { Options } from '@aws-sdk/lib-storage';
import { CreateWriteStreamOptions, File as File$1, StorageOptions } from '@google-cloud/storage';
export { Storage } from '@google-cloud/storage';
import { UploadApiOptions, UploadApiResponse, ResourceType, DeliveryType, ConfigOptions } from 'cloudinary';
export { UploadApiErrorResponse, UploadApiResponse, v2 } from 'cloudinary';
import { DeleteOptions } from '@google-cloud/storage/build/cjs/src/nodejs-common/service-object';

type MulterCallback = (error?: any, info?: Partial<Express.Multer.File>) => void;
type ErrorCallback = (error: Error | null) => void;
interface multerFunctionParams {
    req: Request;
    file: Express.Multer.File;
    cb: MulterCallback;
}
interface File {
    fieldname: string;
    originalname: string;
    encoding: string;
    encryptionKey?: string;
    mimetype: string;
    size: number;
    destination: string;
    filename: string;
    path: string;
    buffer: Buffer;
}
type ProcessedFile = ReadableStream<Uint8Array>;
interface ProcessedMulterFile extends File {
    stream: Readable;
}
type handleFileFn = (req: Request, file: Express.Multer.File, cb: MulterCallback) => void;
type removeFileFn = (re: Request, file: Express.Multer.File, cb: ErrorCallback) => void;
type uploadFn = (req: Request, file: Express.Multer.File, cb: MulterCallback) => Promise<object> | undefined;

interface s3Params extends Omit<PutObjectCommandInput, 'Body' | 'Key'> {
    Key?: string;
}
type s3UploadOptionsFn = ({ req, file, cb }: multerFunctionParams, client: S3Client, params: s3Params, options: s3UploadOptions) => Options;
type s3ResponseFn = (uploadResponse: CompleteMultipartUploadCommandOutput, options: Options) => {
    bucket?: string;
    contentType: string | undefined;
    etag?: string;
    filename?: string;
    metadata: object | undefined;
    path?: string;
    encryption?: string;
    versionId?: string;
};
type contentTypeFn = (filename: string) => string;

interface cloudinaryParams extends UploadApiOptions {
}
type cloudinaryUploadOptionsFn = ({ req, file, cb }: multerFunctionParams, params: cloudinaryParams, options: uploadOptions | null) => UploadApiOptions;
interface cloudinaryApiResponse {
    etag: string;
    filename: string;
    folder: string | null;
    height: number;
    width: number;
    path: string;
    signature: string;
    size: number;
    timeCreated: string;
    versionId: string;
}
type cloudinaryApiResponseFn = (uploadResponse: UploadApiResponse) => cloudinaryApiResponse;
interface cloudinaryDeleteOptions {
    resource_type: ResourceType;
    type: DeliveryType;
    invalidate: boolean;
}

interface gcsParams extends CreateWriteStreamOptions {
    bucket: string;
}
type gcsUploadOptionsFn = ({ req, file, cb }: multerFunctionParams, params: gcsParams, options: uploadOptions) => [CreateWriteStreamOptions, string];
type gcsResponseFn = (uploadResponse: File$1, bucket: string, destFileName: string) => object;

type HostOptions = 'CLOUDINARY' | 'GCS' | 'AWS_S3';
type options = {
    options?: uploadOptions;
};
type s3Options = {
    options?: s3UploadOptions;
};
type CloudinaryTarget = options & {
    target: 'CLOUDINARY';
    config: boolean | ConfigOptions;
    params?: cloudinaryParams;
};
type GcsTarget = options & {
    target: 'GCS';
    config: StorageOptions;
    params: gcsParams;
};
type AwsS3Target = s3Options & {
    target: 'AWS_S3';
    config: S3ClientConfig;
    params: s3Params;
};
type UploadTarget = CloudinaryTarget | AwsS3Target | GcsTarget;
interface uploadOptions {
    chunk_size?: number;
    public_id?: string | ((req: Request, file: File, cb: MulterCallback) => string);
    trash?: string;
    validator?: (req: Request, file: File, cb: MulterCallback) => boolean;
}
type s3UploadOptions = uploadOptions & Omit<Options, 'client' | 'params'>;
interface deleteFileFn {
    (file: string, options?: cloudinaryDeleteOptions): Promise<void>;
    (file: string, options?: DeleteOptions): Promise<void>;
    (file: string, options?: Omit<DeleteObjectCommandInput, 'Bucket' | 'Key'>): Promise<void>;
}

declare class RemoteStorage {
    #private;
    constructor(opts: UploadTarget);
    getTarget(): HostOptions | undefined;
    _handleFile: handleFileFn;
    _removeFile: removeFileFn;
    delete: deleteFileFn;
}

export { type ErrorCallback, type File, type HostOptions, type MulterCallback, type ProcessedFile, type ProcessedMulterFile, RemoteStorage, type UploadTarget, type cloudinaryApiResponse, type cloudinaryApiResponseFn, type cloudinaryDeleteOptions, type cloudinaryParams, type cloudinaryUploadOptionsFn, type contentTypeFn, type deleteFileFn, type gcsParams, type gcsResponseFn, type gcsUploadOptionsFn, type handleFileFn, type multerFunctionParams, type removeFileFn, type s3Params, type s3ResponseFn, type s3UploadOptions, type s3UploadOptionsFn, type uploadFn, type uploadOptions };
